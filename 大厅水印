import os
import re
import ast

def encode_to_hex_utf16le(text):
    """将文本编码为 UTF-16 Little Endian 十六进制字符串"""
    return text.encode('utf-16le').hex().upper()

def replace_in_files(uexp_dir, replacements):
    """在UEXP文件中查找并替换十六进制模式"""
    for filename in os.listdir(uexp_dir):
        if not filename.endswith('.uexp'):
            continue
            
        filepath = os.path.join(uexp_dir, filename)
        print(f"\n处理文件: {filename}")
        
        # 读取二进制文件内容
        with open(filepath, 'rb') as f:
            content = f.read()
        
        hex_content = content.hex().upper()
        original_len = len(hex_content)
        modified = False
        
        # 执行所有替换
        for original_hex, new_hex in replacements.items():
            # 统计替换次数
            count = hex_content.count(original_hex)
            
            if count > 0:
                modified = True
                print(f"  - 找到 {count} 处 {original_hex} ({decode_hex(original_hex)})")
                print(f"  - 替换为 {new_hex} ({decode_hex(new_hex)})")
                
                # 执行替换
                hex_content = hex_content.replace(original_hex, new_hex)
        
        if not modified:
            print("  - 未找到需要替换的内容")
            continue
        
        # 将十六进制字符串转换回字节
        new_content = bytes.fromhex(hex_content)
        
        # 验证长度一致性
        if (len(new_content) * 2) != len(hex_content):
            print("错误: 十六进制转换后长度不匹配，跳过写入")
            continue
        
        # 写回文件
        with open(filepath, 'wb') as f:
            f.write(new_content)
        print(f"  - 文件已更新 (原大小: {original_len//2} 字节, 新大小: {len(new_content)} 字节)")

def decode_hex(hex_str):
    """将十六进制字符串解码为文本(用于显示)"""
    try:
        return bytes.fromhex(hex_str).decode('utf-16le')
    except:
        return f"[无法解码: {hex_str}]"

def main():
    # 获取配置文件路径
    config_path = input("请输入Python配置文件的完整路径: ")
    
    # 读取配置文件内容
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config_content = f.read()
    except Exception as e:
        print(f"读取文件错误: {e}")
        return
    
    # 提取替换规则 - 使用更可靠的方法解析任意格式
    try:
        # 匹配array变量中的所有内容
        match = re.search(r'array\s*=\s*\[([\s\S]*?)\]', config_content)
        if not match:
            print("在配置文件中找不到 array 定义")
            return
        
        # 提取内容并处理为规则列表
        rules_str = match.group(1).strip()
        rules = []
        
        # 按行处理
        for line in rules_str.splitlines():
            line = line.strip()
            if not line or line.startswith('#'):
                continue  # 跳过空行和注释
                
            # 提取键值对
            if '=' in line:
                parts = line.split('=', 1)
                key = parts[0].strip()
                value = parts[1].split('#')[0].strip()  # 移除行内注释
                
                # 处理引号
                if key.startswith("'") and key.endswith("'"):
                    key = key[1:-1]
                if key.startswith('"') and key.endswith('"'):
                    key = key[1:-1]
                if value.startswith("'") and value.endswith("'"):
                    value = value[1:-1]
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                
                rules.append((key, value))
        
        if not rules:
            print("未找到有效的替换规则")
            return
            
        replacements = {}
        for key, value in rules:
            key_hex = encode_to_hex_utf16le(key)
            value_hex = encode_to_hex_utf16le(value)
            replacements[key_hex] = value_hex
        
        print("\n解析的替换规则:")
        for key, value in rules:
            print(f"  {key} -> {value}")
            print(f"    键的十六进制: {encode_to_hex_utf16le(key)}")
            print(f"    值的十六进制: {encode_to_hex_utf16le(value)}")
    
    except Exception as e:
        print(f"解析配置错误: {e}")
        import traceback
        traceback.print_exc()
        return
    
    # 处理UEXP文件
    uexp_dir = "/storage/emulated/0/幻穗制作区/uexp打包/"
    print(f"\n处理目录: {uexp_dir}")
    
    if not os.path.exists(uexp_dir):
        print("错误: UEXP目录不存在")
        return
    
    replace_in_files(uexp_dir, replacements)

if __name__ == "__main__":
    print("幻穗UEXP文件十六进制替换工具")
    print("=" * 50)
    main()
